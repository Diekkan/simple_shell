#ifndef _SIMPLE_SHELL_
#define _SIMPLE_SHELL_
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>

typedef struct path_d
{
	char *directory;
	struct path_d *next;
} path_d;

typedef struct tok
{
	char *token;
	struct tok *next;
} tok;

extern char **environ;

/** shell-made functions */
void shell_prompt(void);
char *read_input(void);
char **tokenizer(char *buffer, char *separator);
char **tokenize_path(void);
char *find_exec();
path_d *pathtokens_to_list(void);
tok *inputtoken_to_list(char **tokenin);
int exec_identifier(path_d *pathlist, char **tokens);
int run_exec(char *pathname, char **tokens);
void env_builtin(void);
int verify_builtin(char **tokens);
void exit_builtin(void);

/** useful functions */
char *_getenv(char *name);
int _strncmp(char *s1, char *s2, int n);
int _strlen(char *str);
path_d *add_node(path_d **head, char *str);
path_d *add_node_pathend(path_d **head, char *str);
tok *add_node_tokens(tok **head, char *str);
tok *add_node_end(tok **head, char *str);
char *_strdup(char *str);
char *_strncat(char *dest, char *src, int n);
void free_list(path_d *head);
void free_array(char **strings, int size);
int _strcmp(char *s1, char *s2);
char *_strstr(char *haystack, char *needle);

#endif
#include "libshell.h"
/**
 *exec_identifier - look for a identifier if found the identifier executes.
 *@pathlist:path variables
 *@tokens:input token.
 *Return: 0.
 */
int exec_identifier(path_d *pathlist, char **tokens)
{
	char *command = tokens[0];
	char *possibledir;
	path_d *directory = pathlist;
	int isdir, isdir2, findfile;
	struct stat st;

	isdir = _strncmp(command, "/", 1);
	isdir2 = _strncmp(command, ".", 1);

	if (isdir == 0 || isdir2 == 0)
	{
		run_exec(command, tokens);
		return (0);
	}

	while (directory)
	{
		possibledir = _strdup(directory->directory);
		possibledir = _strncat(possibledir, "/", 1);
		possibledir = _strncat(possibledir, command, strlen(command));
		findfile = stat(possibledir, &st);
		if (findfile == 0)
		{
			run_exec(possibledir, tokens);
			free(possibledir);
			break;
		}
		directory = directory->next;
	}
	if (findfile != 0)
	{
		free(possibledir);
		perror("Error");
	}
	return (0);
}

/**
 *run_exec - run the executer.
 *@pathname: name of the path.
 *@tokens: tokens value.
 *Return: 0.
 */
int run_exec(char *pathname, char **tokens)
{
	int child_pid = fork();
	int status, err;

	if (child_pid == 0)
	{
		err = execve(pathname, tokens, NULL);
		if (err == -1)
			perror("Error");
	}

	wait(&status);
	return (0);
}

/**
 *env_builtin - print enviroment.
 */

void env_builtin(void)
{
	int i;

	for (i = 0; environ[i] != NULL; i++)
	{
		write(STDOUT_FILENO, environ[i], strlen(environ[i]));
		write(STDOUT_FILENO, "\n", 1);
	}
}

#include "libshell.h"

/**
 * free_array - frees an array of strings
 *@strings: string array
 *
 */
void free_array(char **strings, int size)
{
	int i;
	char *token;

	for (i = 0; i < size; i++)
	{
		token = strings[i];
		free(token);
	}
	free(strings);
}

#include "libshell.h"

/**
 * _strncmp - string compare
 *@s1: string to be compared
 *@s2: string 2
 *@n: number variable.
 * Return: difference between ascii or 0
 */

int _strncmp(char *s1, char *s2, int n)
{
	while (n && *s1 && (*s1 == *s2))
	{
		++s1;
		++s2;
		--n;
	}
	if (n == 0)
	{
		return (0);
	}
	else
	{
		return (*(unsigned char *)s1 - *(unsigned char *)s2);
	}
}

/**
 * _strncat - a function that concatenates two strings
 * @dest: dest string
 * @src: source string
 * @n: n of bytes.
 * Return: dest string modified
 */

char *_strncat(char *dest, char *src, int n)
{
	int chs1;
	int chs2;

	for (chs1 = 0; dest[chs1] != '\0';)
	{
		chs1++;
	}

	for (chs2 = 0; chs2 < n && src[chs2] != '\0';)
	{
		dest[chs1] = src[chs2];
		chs2++;
		chs1++;
	}

	dest[chs1] = '\0';

	return (dest);
}

/**
 * _strdup - copies the string given as parameter.
 *@str: string to be duplicated
 *Return: a pointer to the duplicated string.
 */

char *_strdup(char *str)
{
	char *p;
	unsigned int i, len;

	i = 0;
	len = 0;

	if (str == NULL)
		return (NULL);

	while (str[len])
		len++;

	p = malloc(sizeof(char) * (len + 1));

	if (p == NULL)
		return (NULL);

	while ((p[i] = str[i]) != '\0')
	{
		i++;
	}
	return (p);
}
/**
 * _strlen - a function that returns the lenght of a string.
 * @s: string.
 * Return: 0 success.
 */

int _strlen(char *s)
{
	int string = 0;

	while (*(s + string) != 0)
	{
		string++;
	}

	return (string);
}

/**
 * _strstr - a function that locates a substring.
 *@haystack: base string.
 *@needle: substring to be located in haystack.
 * Return: a pointer to the beginning, NULL if not located.
 */

char *_strstr(char *haystack, char *needle)
{
	char *res;
	char *aux;

	while (*haystack != '\0')
	{
		res = haystack;
		aux = needle;

		while (*aux == *haystack && *aux != '\0'
		       && *haystack != '\0')
		{
			haystack++;
			aux++;
		}
		if (*aux == '\0')
			return (res);
		haystack = res + 1;
	}
	return (NULL);
}
#include "libshell.h"

/**
 *_getenv - function that gets the enviroment.
 *@name: name of the variable.
 *Return:the value of the variable.
 */
char *_getenv(char *name)
{
	char **envtoken, *targetenv = NULL;
	int comparison;
	unsigned int i;


	for (i = 0; environ[i] != NULL; i++)
	{
		comparison = strncmp(environ[i], name, 4);
		if (comparison == 0)
			break;
	}

	if (comparison != 0)
		return (NULL);

	envtoken = tokenizer(environ[i], "=");
	targetenv = envtoken[1];
	return (targetenv);
}
/**
 * tokenize_path - makes token out of a variable path.
 * Return: token directory.
 *
 */

char **tokenize_path(void)
{
	char *path = _getenv("PATH");
	char **pathdirs;

	pathdirs = tokenizer(path, ":");
	return (pathdirs);
}

/**
 * pathtoken_to_list - makes a linked list of directories.
 * @tokens: recibes directories.
 * Return: a pointer to the start of the list.
 */
path_d *pathtokens_to_list(void)
{
	unsigned int i;
	char **tokens = tokenize_path();
	path_d *fNode;

	fNode = NULL;
	i = 0;

	fNode = add_node(&fNode, tokens[i]);
	i++;
	while (tokens[i])
	{
		add_node_pathend(&fNode, tokens[i]);
		i++;
	}
	return (fNode);
}
/**
 * add_node - adds a node in the begining.
 * @head: memory address where is saved.
 * @str: string recibed in the node.
 * Return: a pointer to the list.
 */

path_d *add_node(path_d **head, char *str)
{
	path_d *nNode, *lNode;

	if (!(head && str))
		return (NULL);

	nNode = malloc(sizeof(path_d));
	if (!nNode)
		return (NULL);

	nNode->directory = str;

	if (!nNode->directory)
	{
		free(nNode);
		return (NULL);
	}
	nNode->next = NULL;

	if (!*head)
	{
		*head = nNode;
		return (nNode);
	}

	lNode = *head;
	while (lNode->next)
	{
		lNode = lNode->next;
	}
	lNode->next = nNode;
	return (nNode);
}
/**
 * add_node - adds a node in the begining.
 * @head: memory address where is saved.
 * @str: string recibed in the node.
 * Return: a pointer to the list.
 */
path_d *add_node_pathend(path_d **head, char *str)
{
	path_d *nNode;
	path_d *lNode;

	if (!(head && str))
	return (NULL);

	nNode = malloc(sizeof(path_d));
	if (!nNode)
	return (NULL);

	nNode->directory = str;

	if (!nNode->directory)
	{
		free(nNode);
		return (NULL);
	}
	nNode->next = NULL;

	if (!*head)
	{
		*head = nNode;
		return (nNode);
	}

	lNode = *head;
	while (lNode->next)
	{
		lNode = lNode->next;
	}
	lNode->next = nNode;
	return (nNode);
}
#include "libshell.h"
/**
 *read_input - read input function used to read the input.
 *Return: input.
 */
char *read_input(void)
{
	char *buffer;
	size_t size = 1024;
	int chars;

	buffer = malloc(size * sizeof(char));
	if (buffer == NULL)
		return (NULL);

	chars = getline(&buffer, &size, stdin);

	if (chars == -1)
	{
		write(STDOUT_FILENO, "\n", 1);
		free(buffer);
		return (NULL);
	}

	if (chars > 1)
		buffer[_strlen(buffer) - 1] = '\0';

	return (buffer);
}
#include "libshell.h"
#define UNUSED(x) (void)(x)

/**
 * main - our shell main function.
 * @ac: variable counter.
 * @av: variable vector.
 * @env: variable envairoment.
 * Return: 0.
 */

int main(void)
{
	char *input;
	char **tokens;
	path_d *pathdirs;
	int isaty = 1;

	pathdirs = pathtokens_to_list();

	while (isaty == 1)
	{
		isaty = isatty(STDIN_FILENO);
		if (isaty == 1)
			write(STDOUT_FILENO, "$>", 2);
		else
		{
			isaty = 0;
		}
		input = read_input();
		if (input == NULL || _strncmp(input, "exit", 4) == 0)
			break;
		if (_strncmp(input, "\n", 1) == 0 ||
		_strncmp(input, "env", 3) == 0)
		{
			if (_strncmp(input, "env", 3) == 0)
				env_builtin();

			continue;
		}
		tokens = tokenizer(input, " ");
		exec_identifier(pathdirs, tokens);
	}

	return (0);

}
#include "libshell.h"

/**
 * shell_prompt - prints shell's prompt message.
 */

void shell_prompt(void)
{
		printf("$shell(0.1)# ");
}
#include "libshell.h"
/**
 * _strtok - makes the tokens.
 * @string: recibe string to be tokenized.
 * @separator: add a separator.
 * Return: token.
 */
char *_strtok(char *string, char separator)
{
	unsigned int i;
	char *token;

	token = malloc(sizeof(char) * strlen(string) + 1);
	if (token == NULL)
		return (NULL);

	for (i = 0; string[i] != separator; i++)
	{
		string[i] = token[i];
	}
	string[i] = '\0';

	return (token);
}
#include "libshell.h"

/**
 * tokenizer - tokenizes the input received.
 *@buffer: string received from input.
 *@separator: separetor character.
 *Return: returns an array of strings.
 */

char **tokenizer(char *buffer, char *separator)
{
	int i = 0;
	char **tokenized;
	char *token;
	size_t size = 1024;

	token = strtok(buffer, separator);
	tokenized = malloc(sizeof(char *) * size);
	if (tokenized == NULL)
		return (NULL);

	while (token)
	{
		tokenized[i] = token;
		token = strtok(NULL, separator);
		i++;
	}

	tokenized[i] = NULL;
	return (tokenized);
}

/**
 * free_list -a function that frees a list_t list.
 * @head: first node.
 */
void free_list(path_d *head)
{
	path_d *next;

	while (head)
	{
		next = head->next;
		free(head->directory);
		free(head);
		head = next;
	}

	head = NULL;
}
